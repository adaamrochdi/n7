[comment encoding = UTF-8 /]
[module generate('http://table')]

[template public generateElement(aTable : Table)]
[comment @main/]
[file ('sortie.py', false, 'UTF-8')]
import pandas as pd
from tkinter import *
from tkinter import ttk, filedialog, messagebox
[for (sc : Script | aTable.script)]
from [sc.nom/] import [sc.nom/]
[/for]
# Classe pour gérer la table et les calculs
class TableManager:

    def __init__(self, gui, initial_data):
        self.data = initial_data
        self.entries = ['[]'/]
        self.total_rows, self.total_columns = initial_data.shape

        # Création de l'interface graphique
        for i in range(self.total_rows + 1):  # Ligne supplémentaire pour les noms de colonnes
            row_entries = ['[]'/]
            for j in range(self.total_columns):
                if i == 0:
                    # Ajout des entêtes
                    entry = Entry(gui, width=20, bg='LightSteelBlue', fg='Black',
                                  font=('Arial', 16, 'bold'))
                    entry.insert(END, initial_data.columns['[j]'/])  # Affiche les noms des colonnes
                else:
                    # Ajout des données
                    entry = Entry(gui, width=20, fg='blue', font=('Arial', 16, ''))
                    entry.insert(END, initial_data.iloc['['/]i - 1, j[']'/])
                entry.grid(row=i, column=j)
                row_entries.append(entry)
            self.entries.append(row_entries)

    def update_data(self):
        # Mise à jour des données du tableau
        for i in range(1, self.total_rows + 1):  # Commence à la ligne 1 (ignorer les entêtes)
            for j in range(self.total_columns):
                self.data.iloc['['/]i - 1, j] = self.entries['['/]i]['['/]j].get()

    def clear_table(self):
        # Efface toutes les cellules du tableau
        for i in range(self.total_rows + 1):
            for j in range(self.total_columns):
                self.entries['['/]i]['['/]j].delete(0, END)

    def resize_table(self, new_rows, new_columns):
        # Redimensionne le tableau
        for i in range(self.total_rows + 1):
            for j in range(self.total_columns):
                self.entries['['/]i]['['/]j].destroy()

        self.total_rows, self.total_columns = new_rows, new_columns

        # Création de nouvelles entrées
        self.entries = ['[]'/]
        for i in range(self.total_rows + 1):
            row_entries = ['[]'/]
            for j in range(self.total_columns):
                if i == 0:
                    entry = Entry(gui, width=20, bg='LightSteelBlue', fg='Black',
                                  font=('Arial', 16, 'bold'))
                else:
                    entry = Entry(gui, width=20, fg='blue', font=('Arial', 16, ''))
                entry.grid(row=i, column=j)
                if i < self.data.shape['['/]0] and j < self.data.shape['['/]1]:
                    entry.insert(END, self.data.iloc['['/]i - 1, j])
                row_entries.append(entry)
            self.entries.append(row_entries)
# Fonction pour charger un fichier CSV et l'afficher
def upload_csv():
    file_path = filedialog.askopenfilename(filetypes=['['/]("CSV files", "*.csv")])
    if file_path:
        try:
            new_data = pd.read_csv(file_path)
            table_manager.resize_table(new_data.shape['['/]0], new_data.shape['['/]1])
            table_manager.data = new_data
            for i in range(table_manager.total_rows + 1):  
                for j in range(table_manager.total_columns):
                    if i < len(table_manager.entries) and j < len(table_manager.entries['['/]i]):
                        table_manager.entries['['/]i]['['/]j].delete(0, END)
                        if i == 0 and j < new_data.shape['['/]1]:
                            table_manager.entries['['/]i]['['/]j].insert(END, new_data.columns['['/]j])
                        elif i - 1 < new_data.shape['['/]0] and j < new_data.shape['['/]1]:
                            table_manager.entries['['/]i]['['/]j].insert(END, new_data.iloc['['/]i - 1, j])

            save_button.grid(columnspan=table_manager.total_columns)
            calculation_button.grid(columnspan=table_manager.total_columns)
            upload_button.grid(columnspan=table_manager.total_columns)

        except pd.errors.EmptyDataError:
            print("Empty CSV file")
def save_table_to_csv():
    table_manager.update_data()  
    file_path = filedialog.asksaveasfilename(defaultextension=".csv", filetypes=['['/]("CSV files", "*.csv")])
    if file_path:
        try:
            table_manager.data.to_csv(file_path, index=False)
            print(f"Table saved to {file_path}")
        except Exception as e:
            print(f"Error saving the table: {e}")
# Fonction pour créer le DataFrame à partir du modèle
def creer_dataframe():
    """Créer un DataFrame basé sur le modèle XMI"""
    colonnes = {}
    [for (col : Colonne | aTable.tablesource.colonneid)]
    colonnes['['/]'[col.nom/]'] = ['['/][col.valeurs->collect(v | '"' + v.toString() + '"')->sep(', ')/]];    
    [/for]
    [for (col : Colonne | aTable.tablesource.colonnesaisie)]
    colonnes['['/]'[col.nom/]'] = ['['/][col.valeurs->collect(v | '"' + v.toString() + '"')->sep(', ')/]];    
    [/for]
    [for (col : Colonne | aTable.tableresultante.colonneidresultante)]
    colonnes['['/]'[col.nom/]'] = ['['/][col.valeurs->collect(v | '"' + v.toString() + '"')->sep(', ')/]];    
    [/for]
    [for (col : Colonne | aTable.tableresultante.colonnederiv)]
    colonnes['['/]'[col.nom/]'] = ['['/][col.valeurs->collect(v | '"' + v.toString() + '"')->sep(', ')/]];    
    [/for]
    # Retourner le DataFrame
    return pd.DataFrame(colonnes)

def compute_calcul(df):
    # Appliquer les scripts pour calculer les colonnes dérivées
    [for (sc : Script | aTable.script)]
	[for (colEntree : Colonne | sc.entree)]
    df['['/]"[colEntree.nom/]"] = df['['/]"[colEntree.nom/]"].astype(float)
    [/for]
    df['['/]"[sc.sortie.nom/]"] = list(map([sc.nom/][for (colEntree : Colonne | sc.entree)],df['['/]"[colEntree.nom/]"].to_list()[/for]))
    [/for]

    # Une fois les colonnes dérivées calculées, on les convertit également en chaînes avec guillemets
    [for (col : ColonneDeriv | aTable.tableresultante.colonnederiv)]
    df['['/]"[col.nom/]"] = df['['/]"[col.nom/]"].astype(str)
    [/for]
    return df

def verifier_contraintes(df):
    """
    Vérifie les contraintes définies sur les colonnes d'un DataFrame.
    Retourne 'OK' si toutes les contraintes sont respectées, sinon un message d'erreurs.
    """
    erreurs = ['['/]]

    # Vérifications des contraintes pour les colonnes des tables source
[for (tableSrc : TableSource | aTable.tablesource)]
[for (col : Colonne | tableSrc.colonneid->union(tableSrc.colonnesaisie))]
[for (ctr : ContrainteOperation | col.contrainte)]
    [if ctr.type = OpContrainte::SUP]
    if not (df['['/]'[col.nom/]'].astype(float) > [ctr.vComparee/]).all():
        erreurs.append(f"La contrainte > [ctr.vComparee/] n'est pas vérifiée pour la colonne [col.nom/]")
    [/if]
    [if ctr.type = OpContrainte::INF]
    if not (df['['/]'[col.nom/]'].astype(float) < [ctr.vComparee/]).all():
        erreurs.append(f"La contrainte < [ctr.vComparee/] n'est pas vérifiée pour la colonne [col.nom/]")
    [/if]
    [if ctr.type = OpContrainte::EGAL]
    if not (df['['/]'[col.nom/]'].astype(float) == [ctr.vComparee/]).all():
        erreurs.append(f"La contrainte == [ctr.vComparee/] n'est pas vérifiée pour la colonne [col.nom/]")
    [/if]
    [if ctr.type = OpContrainte::SUP_OU_EGAL]
    if not (df['['/]'[col.nom/]'].astype(float) >= [ctr.vComparee/]).all():
        erreurs.append(f"La contrainte >= [ctr.vComparee/] n'est pas vérifiée pour la colonne [col.nom/]")
    [/if]
    [if ctr.type = OpContrainte::INF_OU_EGAL]
    if not (df['['/]'[col.nom/]'].astype(float) <= [ctr.vComparee/]).all():
        erreurs.append(f"La contrainte <= [ctr.vComparee/] n'est pas vérifiée pour la colonne [col.nom/]")
    [/if]
[/for]
[/for]
[/for]

    # Vérifications des contraintes pour les colonnes des tables résultantes
[for (tableRes : TableResultante | aTable.tableresultante)]
[for (col : Colonne | tableRes.colonneidresultante->union(tableRes.colonnesaisieres)->union(tableRes.colonnederiv))]
[for (ctr : ContrainteOperation | col.contrainte)]
    [if ctr.type = OpContrainte::SUP]
    if not (df['['/]'[col.nom/]'].astype(float) > [ctr.vComparee/]).all():
        erreurs.append(f"La contrainte > [ctr.vComparee/] n'est pas vérifiée pour la colonne [col.nom/]")
    [/if]
    [if ctr.type = OpContrainte::INF]
    if not (df['['/]'[col.nom/]'].astype(float) < [ctr.vComparee/]).all():
        erreurs.append(f"La contrainte < [ctr.vComparee/] n'est pas vérifiée pour la colonne [col.nom/]")
    [/if]
    [if ctr.type = OpContrainte::EGAL]
    if not (df['['/]'[col.nom/]'].astype(float) == [ctr.vComparee/]).all():
        erreurs.append(f"La contrainte == [ctr.vComparee/] n'est pas vérifiée pour la colonne [col.nom/]")
    [/if]
    [if ctr.type = OpContrainte::SUP_OU_EGAL]
    if not (df['['/]'[col.nom/]'].astype(float) >= [ctr.vComparee/]).all():
        erreurs.append(f"La contrainte >= [ctr.vComparee/] n'est pas vérifiée pour la colonne [col.nom/]")
    [/if]
    [if ctr.type = OpContrainte::INF_OU_EGAL]
    if not (df['['/]'[col.nom/]'].astype(float) <= [ctr.vComparee/]).all():
        erreurs.append(f"La contrainte <= [ctr.vComparee/] n'est pas vérifiée pour la colonne [col.nom/]")
    [/if]
[/for]
[/for]
[/for]

    if len(erreurs) == 0:
        return "OK"
    else:
        return "\n".join(erreurs)


# Création du DataFrame à partir du modèle
df = creer_dataframe()
# Calcul des colonnes dérivées
df = compute_calcul(df)

# Création de l'interface graphique principale
gui = Tk()
table_manager = TableManager(gui, df)

# Boutons et événements

# Bouton pour vérifier les contraintes
def verifier_button_action():
	result = verifier_contraintes(table_manager.data)
	messagebox.showinfo("Vérification des contraintes", result)

verifier_button = Button(gui, text="Vérifier Contraintes", command=verifier_button_action)
verifier_button.grid(row=table_manager.total_rows + 3, columnspan=table_manager.total_columns)

save_button = Button(gui, text="Save", command=lambda: table_manager.update_data())
save_button.grid(row=table_manager.total_rows + 1, columnspan=table_manager.total_columns)

# Créer le bouton pour charger le CSV
upload_button = Button(gui, text="Upload CSV", command=upload_csv)
upload_button.grid(row=table_manager.total_rows + 4, columnspan=table_manager.total_columns)

# Créer le bouton pour sauvragrder le CSV
to_csv_button = Button(gui, text="Save CSV", command=save_table_to_csv)
to_csv_button.grid(row=table_manager.total_rows + 2, columnspan=table_manager.total_columns)

# Lancer l'interface graphique
gui.mainloop()
[/file]
[/template]
